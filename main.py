import numpy as np

from lib import *

# Таблица синдромов ошибок
#syndrome_table = [ [0, 0, 0], [1, 0, 1], [1, 1, 1], [1, 1, 0],                                                  # // для (7, 4)-кода
#                   [0, 1, 1], [1, 0, 0], [0, 1, 0], [0, 0, 1]
#                 ]

syndrome_table = [ [0, 0, 0, 0, 0], [1, 0, 0, 1, 1], [1, 1, 0, 1, 0], [0, 1, 1, 0, 0], [1, 0, 1, 0, 1],        # // для (14, 9)-кода
                   [1, 1, 0, 0, 1], [1, 1, 1, 1, 1], [1, 1, 1, 0, 0], [0, 1, 1, 1, 1], [0, 0, 1, 1, 1],
                   [1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]
                 ]

                                                                                                                # // для (28, 21)-кода
#syndrome_table = [ [0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 0], [0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 0, 1, 1], [1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 0, 1],
#                   [1, 1, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1], [1, 1, 0, 1, 1, 1, 1], [1, 1, 0, 1, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0],
#                   [0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 1, 1], [1, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1, 1]
#                 ]

def bit_error(syndrome):
    i = 1
    for element in syndrome_table:
        if syndrome == element:
            return i
        i += 1

if __name__ == "__main__":
    # gX = input("Введите порождающий многочлен: ")
    # gX = "1011"                             #        //  для (7, 4)-кода: t=3, c=0, L=1
    gX = "100111"                           #       // для (14, 9)-кода: t=3, c=2, L=1
    # gX = "10111011"                           #      //  для (28, 21)-кода: t=3, c=4, L=2
    print("Порождающий многочлен:", gX)
    gX = [int(char) for char in gX]

    # L = input("Введите длину пакета ошибок")
    L = 1

    # message = input("Введите сообщение: ")
    # message = "0010"
    message = "011001110"
    # message = "000010111000111000111"
    print("Сообщение:", message)
    message = [int(char) for char in message]
    # err = input("Введите номер искаженного бита: ")
    err = 9
    print()

    Code = FireCode(gX)
    full_message = Code.code(message)
    match L:
        case 1:
            print("В каком бите будет ошибка: ", err)
            codedMsg = Code.add_errors(err, full_message)
        case 2:
            print("В каких битах будет ошибка:", err," - ", err+1)
            codedMsg = Code.add_errors2(err, err, full_message)
    print("Сообщение c дополнительными битами:", full_message)
    print("Полученное сообщение:\t\t   ", np.array(codedMsg))
    error_syndrome = list(Code.decode(codedMsg))
    
    i = bit_error(error_syndrome)               # по таблице синдромов определяем в каком именно бите-битах искажение
    if i == 1:                                  # если получен нулевой синдром, значит, сообщение не было искажено
        print("Ошибки нет")
    else:
        E = 1
        match L:
            case 1:                             # если код исправляет пакет длинной 1, исправляем всего 1 бит, вычисленный по таблице синдромов
                print(f"Ошибка в бите {i-1}")
                if codedMsg[i-2] == 0:
                    codedMsg[i-2] = 1
                else:
                    codedMsg[i-2] = 0
            case 2:                                   #  если код исправляет пакет длинной 2, исправляем 2 бита, вычисленные по таблице синдромов
                print(f"Ошибка в битах {i-1} - {i}")
                if codedMsg[i-2] == 0:
                    codedMsg[i-2] = 1
                else:
                    codedMsg[i-2] = 0
                if codedMsg[i-1] == 0:
                    codedMsg[i-1] = 1
                else:
                    codedMsg[i-1] = 0

    print()

    i = len(gX) - np.min(np.nonzero(gX)) - 1                # рассчитываем количество проверочных бит
    codedMsg = codedMsg[:-i]                                # убираем их из полученного и исправленнного сообщения
    print("Оригинальное сообщение:   ", np.array(message))
    print("Декодированное сообщение: ", codedMsg)
